package report

import (
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/yourusername/tplan/internal/models"
)

// Generator handles report generation
type Generator struct {
	plan         *models.PlanResult
	includeDrift bool
}

// NewGenerator creates a new report generator
func NewGenerator(plan *models.PlanResult, includeDrift bool) *Generator {
	return &Generator{
		plan:         plan,
		includeDrift: includeDrift,
	}
}

// GenerateMarkdown creates a detailed Markdown report
func (g *Generator) GenerateMarkdown() string {
	var b strings.Builder

	// Title and timestamp
	b.WriteString("# Terraform Plan Report\n\n")
	b.WriteString(fmt.Sprintf("**Generated:** %s\n\n", time.Now().Format("2006-01-02 15:04:05 MST")))

	if g.plan.TerraformVersion != "" {
		b.WriteString(fmt.Sprintf("**Terraform Version:** %s\n\n", g.plan.TerraformVersion))
	}

	// Executive Summary
	b.WriteString("## Executive Summary\n\n")
	b.WriteString(g.generateSummary())
	b.WriteString("\n")

	// Drift Detection Notice
	if g.includeDrift {
		b.WriteString("**Note:** This report includes git drift analysis.\n\n")
	}

	// Table of Contents
	b.WriteString("## Table of Contents\n\n")
	b.WriteString("- [Executive Summary](#executive-summary)\n")
	if g.plan.Summary.ToCreate > 0 {
		b.WriteString("- [Resources to Create](#resources-to-create)\n")
	}
	if g.plan.Summary.ToUpdate > 0 {
		b.WriteString("- [Resources to Update](#resources-to-update)\n")
	}
	if g.plan.Summary.ToDelete > 0 {
		b.WriteString("- [Resources to Delete](#resources-to-delete)\n")
	}
	if g.plan.Summary.ToReplace > 0 {
		b.WriteString("- [Resources to Replace](#resources-to-replace)\n")
	}
	if len(g.plan.Errors) > 0 {
		b.WriteString("- [Errors](#errors)\n")
	}
	if len(g.plan.Warnings) > 0 {
		b.WriteString("- [Warnings](#warnings)\n")
	}
	b.WriteString("\n---\n\n")

	// Resource Changes by Action
	if g.plan.Summary.ToCreate > 0 {
		b.WriteString("## Resources to Create\n\n")
		b.WriteString(g.generateResourceSection(models.ActionCreate))
		b.WriteString("\n")
	}

	if g.plan.Summary.ToUpdate > 0 {
		b.WriteString("## Resources to Update\n\n")
		b.WriteString(g.generateResourceSection(models.ActionUpdate))
		b.WriteString("\n")
	}

	if g.plan.Summary.ToDelete > 0 {
		b.WriteString("## Resources to Delete\n\n")
		b.WriteString(g.generateResourceSection(models.ActionDelete))
		b.WriteString("\n")
	}

	if g.plan.Summary.ToReplace > 0 {
		b.WriteString("## Resources to Replace\n\n")
		b.WriteString(g.generateResourceSection(models.ActionReplace))
		b.WriteString("\n")
	}

	// Errors
	if len(g.plan.Errors) > 0 {
		b.WriteString("## Errors\n\n")
		b.WriteString(g.generateErrors())
		b.WriteString("\n")
	}

	// Warnings
	if len(g.plan.Warnings) > 0 {
		b.WriteString("## Warnings\n\n")
		b.WriteString(g.generateWarnings())
		b.WriteString("\n")
	}

	// Footer
	b.WriteString("---\n\n")
	b.WriteString("*Generated by tplan - Terraform Plan TUI Viewer*\n")

	return b.String()
}

// generateSummary creates the executive summary section
func (g *Generator) generateSummary() string {
	var b strings.Builder

	summary := g.plan.Summary

	b.WriteString("| Action | Count |\n")
	b.WriteString("|--------|-------|\n")
	b.WriteString(fmt.Sprintf("| üü¢ Create | %d |\n", summary.ToCreate))
	b.WriteString(fmt.Sprintf("| üü° Update | %d |\n", summary.ToUpdate))
	b.WriteString(fmt.Sprintf("| üî¥ Delete | %d |\n", summary.ToDelete))
	b.WriteString(fmt.Sprintf("| üîµ Replace | %d |\n", summary.ToReplace))
	b.WriteString(fmt.Sprintf("| **Total Changes** | **%d** |\n", summary.Total))

	if len(g.plan.Errors) > 0 {
		b.WriteString(fmt.Sprintf("| ‚ùå Errors | %d |\n", len(g.plan.Errors)))
	}
	if len(g.plan.Warnings) > 0 {
		b.WriteString(fmt.Sprintf("| ‚ö†Ô∏è Warnings | %d |\n", len(g.plan.Warnings)))
	}

	return b.String()
}

// generateResourceSection generates a section for a specific action type
func (g *Generator) generateResourceSection(action models.ChangeAction) string {
	var b strings.Builder

	resources := g.getResourcesByAction(action)
	if len(resources) == 0 {
		return ""
	}

	for i, res := range resources {
		b.WriteString(fmt.Sprintf("### %d. %s\n\n", i+1, res.Address))

		// Resource metadata
		b.WriteString("**Details:**\n")
		b.WriteString(fmt.Sprintf("- **Type:** `%s`\n", res.Type))
		b.WriteString(fmt.Sprintf("- **Provider:** `%s`\n", res.ProviderName))
		if res.Module != "" {
			b.WriteString(fmt.Sprintf("- **Module:** `%s`\n", res.Module))
		}
		b.WriteString(fmt.Sprintf("- **Action:** `%s`\n", action))
		if res.ActionReason != "" {
			b.WriteString(fmt.Sprintf("- **Reason:** %s\n", res.ActionReason))
		}
		b.WriteString("\n")

		// Git information (if drift mode is enabled and available)
		if g.includeDrift && res.DriftInfo != nil && res.DriftInfo.IsValid() {
			b.WriteString("**Git Information:**\n")
			b.WriteString(fmt.Sprintf("- **File:** `%s`\n", res.DriftInfo.FilePath))
			b.WriteString(fmt.Sprintf("- **Commit:** `%s`\n", res.DriftInfo.ShortCommitID()))
			b.WriteString(fmt.Sprintf("- **Branch:** `%s`\n", res.DriftInfo.BranchName))
			b.WriteString(fmt.Sprintf("- **Author:** %s <%s>\n", res.DriftInfo.AuthorName, res.DriftInfo.AuthorEmail))
			b.WriteString(fmt.Sprintf("- **Date:** %s\n", res.DriftInfo.CommitDate.Format("2006-01-02 15:04:05")))
			if res.DriftInfo.CommitMessage != "" {
				b.WriteString(fmt.Sprintf("- **Commit Message:** %s\n", res.DriftInfo.CommitMessage))
			}
			if res.DriftInfo.HasUncommittedChanges {
				b.WriteString("- **Status:** ‚ö†Ô∏è Has uncommitted changes\n")
			}
			b.WriteString("\n")
		}

		// Attribute changes
		b.WriteString(g.generateAttributeChanges(res, action))
		b.WriteString("\n")
	}

	return b.String()
}

// generateAttributeChanges generates the attribute changes for a resource
func (g *Generator) generateAttributeChanges(res models.ResourceChange, action models.ChangeAction) string {
	var b strings.Builder

	before := res.Change.Before
	after := res.Change.After

	switch action {
	case models.ActionCreate:
		if len(after) > 0 {
			b.WriteString("**Attributes:**\n")
			b.WriteString("```hcl\n")
			g.writeAttributes(after, &b, "")
			b.WriteString("```\n")
		}

	case models.ActionDelete:
		if len(before) > 0 {
			b.WriteString("**Attributes to be removed:**\n")
			b.WriteString("```hcl\n")
			g.writeAttributes(before, &b, "")
			b.WriteString("```\n")
		}

	case models.ActionUpdate, models.ActionReplace:
		b.WriteString("**Changes:**\n\n")

		// Find modified attributes
		modified := false
		for k, afterVal := range after {
			if beforeVal, exists := before[k]; exists {
				beforeStr := fmt.Sprintf("%v", beforeVal)
				afterStr := fmt.Sprintf("%v", afterVal)
				if beforeStr != afterStr {
					if !modified {
						b.WriteString("| Attribute | Before | After |\n")
						b.WriteString("|-----------|--------|-------|\n")
						modified = true
					}
					b.WriteString(fmt.Sprintf("| `%s` | `%s` | `%s` |\n", k, truncate(beforeStr, 40), truncate(afterStr, 40)))
				}
			} else {
				// New attribute
				if !modified {
					b.WriteString("| Attribute | Before | After |\n")
					b.WriteString("|-----------|--------|-------|\n")
					modified = true
				}
				afterStr := fmt.Sprintf("%v", afterVal)
				b.WriteString(fmt.Sprintf("| `%s` | *(not set)* | `%s` |\n", k, truncate(afterStr, 40)))
			}
		}

		// Find removed attributes
		for k, beforeVal := range before {
			if _, exists := after[k]; !exists {
				if !modified {
					b.WriteString("| Attribute | Before | After |\n")
					b.WriteString("|-----------|--------|-------|\n")
					modified = true
				}
				beforeStr := fmt.Sprintf("%v", beforeVal)
				b.WriteString(fmt.Sprintf("| `%s` | `%s` | *(removed)* |\n", k, truncate(beforeStr, 40)))
			}
		}

		if !modified {
			b.WriteString("*No attribute changes detected (may be internal resource changes)*\n")
		}
		b.WriteString("\n")
	}

	return b.String()
}

// writeAttributes writes attributes in HCL-like format
func (g *Generator) writeAttributes(attrs map[string]interface{}, b *strings.Builder, indent string) {
	maxDisplay := 20
	count := 0
	for k, v := range attrs {
		if count >= maxDisplay {
			b.WriteString(indent + "...\n")
			break
		}
		valueStr := fmt.Sprintf("%v", v)
		if len(valueStr) > 60 {
			valueStr = valueStr[:57] + "..."
		}
		b.WriteString(fmt.Sprintf("%s%s = %s\n", indent, k, valueStr))
		count++
	}
}

// getResourcesByAction filters resources by action type
func (g *Generator) getResourcesByAction(action models.ChangeAction) []models.ResourceChange {
	var resources []models.ResourceChange
	for _, res := range g.plan.Resources {
		if res.Action == action {
			resources = append(resources, res)
		}
	}
	return resources
}

// generateErrors generates the errors section
func (g *Generator) generateErrors() string {
	var b strings.Builder

	for i, err := range g.plan.Errors {
		b.WriteString(fmt.Sprintf("### Error %d\n\n", i+1))
		if err.Resource != "" {
			b.WriteString(fmt.Sprintf("**Resource:** `%s`\n\n", err.Resource))
		}
		if err.Severity != "" {
			b.WriteString(fmt.Sprintf("**Severity:** %s\n\n", err.Severity))
		}
		b.WriteString(fmt.Sprintf("**Message:**\n```\n%s\n```\n\n", err.Message))
	}

	return b.String()
}

// generateWarnings generates the warnings section
func (g *Generator) generateWarnings() string {
	var b strings.Builder

	for i, warn := range g.plan.Warnings {
		b.WriteString(fmt.Sprintf("### Warning %d\n\n", i+1))
		if warn.Resource != "" {
			b.WriteString(fmt.Sprintf("**Resource:** `%s`\n\n", warn.Resource))
		}
		b.WriteString(fmt.Sprintf("**Message:**\n```\n%s\n```\n\n", warn.Message))
	}

	return b.String()
}

// WriteToFile writes the report to a file
func (g *Generator) WriteToFile(filename string) error {
	content := g.GenerateMarkdown()
	return os.WriteFile(filename, []byte(content), 0644)
}

// truncate truncates a string to a maximum length
func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}
