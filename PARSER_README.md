# Terraform Plan Parser

A comprehensive Terraform plan parser that can read and parse both human-readable text and JSON format Terraform plans.

## Features

- **Dual Format Support**: Automatically detects and parses both text and JSON plan formats
- **Complete Resource Information**: Extracts resource addresses, types, names, actions, and state changes
- **Action Detection**: Identifies create, update, delete, replace, and no-op actions
- **Error & Warning Capture**: Parses errors and warnings from plan output
- **Drift Detection**: Identifies resources that have drifted from expected state
- **Output Changes**: Tracks changes to Terraform outputs
- **Summary Statistics**: Provides aggregate statistics on plan changes

## Data Models

### PlanResult
Main struct containing all parsed plan information:
```go
type PlanResult struct {
    Resources        []ResourceChange
    OutputChanges    []OutputChange
    FormatVersion    string
    TerraformVersion string
    Summary          PlanSummary
    Errors           []PlanError
    Warnings         []PlanWarning
    DriftDetected    bool
    DriftedResources []DriftedResource
    ParsedAt         time.Time
    InputFormat      string // "json" or "text"
}
```

### ResourceChange
Information about a single resource change:
```go
type ResourceChange struct {
    Address      string
    Type         string
    Name         string
    Module       string
    Mode         string // "managed" or "data"
    ProviderName string
    Change       Change
    Action       ChangeAction
    ActionReason string
    Index        interface{}
    Deposed      string
}
```

### ChangeAction
Enum for resource actions:
```go
const (
    ActionCreate  ChangeAction = "create"
    ActionUpdate  ChangeAction = "update"
    ActionDelete  ChangeAction = "delete"
    ActionReplace ChangeAction = "replace"
    ActionRead    ChangeAction = "read"
    ActionNoOp    ChangeAction = "no-op"
)
```

### Change
Before/after state information:
```go
type Change struct {
    Actions        []string
    Before         map[string]interface{}
    After          map[string]interface{}
    AfterUnknown   map[string]interface{}
    BeforeSensitive map[string]interface{}
    AfterSensitive  map[string]interface{}
    ReplacePaths   [][]interface{}
}
```

## Usage

### Basic Usage

```go
package main

import (
    "fmt"
    "os"
    "github.com/yourusername/tplan/internal/parser"
)

func main() {
    // Create parser
    p := parser.NewParser()
    
    // Parse from stdin (auto-detects format)
    result, err := p.Parse(os.Stdin)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
    
    // Access parsed data
    fmt.Printf("Total resources: %d\n", result.Summary.Total)
    fmt.Printf("To create: %d\n", result.Summary.ToCreate)
    fmt.Printf("To update: %d\n", result.Summary.ToUpdate)
    fmt.Printf("To delete: %d\n", result.Summary.ToDelete)
}
```

### Parse from File

```go
// Parse from file
result, err := parser.ParseFile("plan.json")
if err != nil {
    log.Fatal(err)
}
```

### Parse from String

```go
planOutput := `... terraform plan output ...`
result, err := parser.ParseString(planOutput)
if err != nil {
    log.Fatal(err)
}
```

### Iterate Over Resources

```go
for _, rc := range result.Resources {
    fmt.Printf("[%s] %s\n", rc.Action, rc.Address)
    fmt.Printf("  Type: %s\n", rc.Type)
    fmt.Printf("  Name: %s\n", rc.Name)
    
    if rc.Action == models.ActionReplace {
        fmt.Printf("  Reason: %s\n", rc.ActionReason)
    }
}
```

### Check for Errors and Warnings

```go
if len(result.Errors) > 0 {
    fmt.Println("Errors found:")
    for _, e := range result.Errors {
        fmt.Printf("  - %s\n", e.Message)
    }
}

if len(result.Warnings) > 0 {
    fmt.Println("Warnings:")
    for _, w := range result.Warnings {
        fmt.Printf("  - %s\n", w.Message)
    }
}
```

### Drift Detection

```go
if result.DriftDetected {
    fmt.Printf("Drift detected in %d resources:\n", len(result.DriftedResources))
    for _, dr := range result.DriftedResources {
        fmt.Printf("  - %s: %s\n", dr.Address, dr.DriftReason)
    }
}
```

## Command Line Usage

### Parse JSON plan:
```bash
# From file
go run examples/test_parser.go plan.json

# From terraform command
terraform plan -json | go run examples/test_parser.go -
```

### Parse text plan:
```bash
# From file
go run examples/test_parser.go plan.txt

# From terraform command
terraform plan | go run examples/test_parser.go -
```

## Input Formats

### JSON Format
Generated by `terraform plan -json` or `terraform show -json plan.tfplan`:
```bash
terraform plan -json > plan.json
```

### Text Format
Standard Terraform plan output:
```bash
terraform plan > plan.txt
```

## Testing

Run the included example:
```bash
# Create a test plan
cat > test_plan.json << 'EOF'
{
  "format_version": "1.1",
  "terraform_version": "1.5.0",
  "resource_changes": [...]
}
EOF

# Test the parser
go run examples/test_parser.go test_plan.json
```

## Error Handling

The parser includes robust error handling:

- **Empty Input**: Returns error if no input provided
- **Invalid JSON**: Returns parse error with details
- **Malformed Text**: Attempts best-effort parsing
- **Strict Mode**: Optional strict parsing mode for validation

```go
p := parser.NewParser()
p.SetStrictMode(true)  // Enable strict validation
result, err := p.Parse(reader)
```

## Implementation Details

### Format Detection
The parser automatically detects the input format by:
1. Checking for JSON object markers
2. Looking for Terraform-specific text patterns
3. Attempting JSON parse as fallback
4. Defaulting to text format

### Text Parsing
Uses regular expressions to extract:
- Resource headers (symbols: +, -, ~, -/+)
- Resource actions and addresses
- Attribute changes
- Errors and warnings
- Drift notifications

### JSON Parsing
Leverages the `hashicorp/terraform-json` library for:
- Type-safe parsing
- Complete resource change information
- Output change tracking
- Version metadata

## Limitations

### Text Format Parsing
- Simplified attribute parsing (complex nested structures may not be fully captured)
- Resource address parsing handles basic cases (some edge cases with complex modules may need refinement)
- Drift detection relies on keyword matching

### JSON Format Parsing
- Requires Terraform 0.12+ format
- Some fields may vary by Terraform version
- Replace paths parsing depends on library version

## Future Enhancements

- [ ] Enhanced text format parsing for complex attributes
- [ ] Module path resolution
- [ ] Resource dependency tracking
- [ ] Change impact analysis
- [ ] Sensitive value handling
- [ ] Provider configuration extraction
- [ ] Plan comparison functionality

## License

See main project LICENSE file.
